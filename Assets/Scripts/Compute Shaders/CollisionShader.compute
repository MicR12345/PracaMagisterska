// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CollisionKernel
struct Connectors
{
    float connectionL[24];
    int number[24];
};
struct SimplePointStr
{
    float3 position;
    float mass;
    int connectorCount;
    int ignorePhysics;
    float3 movePosition;
    float3 velocity;
    Connectors connectorPositions;
};
struct SimpleTriangle 
{
    int t1;
    int t2;
    int t3;
};
struct BoundingBox {
    float3 maxP;
    float3 minP;
};
BoundingBox CalculateBoundingBoxTriangle(float3 t1, float3 t2, float3 t3) 
{
    float maxX = max(t1.x, t2.x);
    maxX = max(maxX, t3.x);
    float maxY = max(t1.y, t2.y);
    maxY = max(maxY, t3.y);
    float maxZ = max(t1.z, t2.z);
    maxZ = max(maxZ, t3.z);
    float minX = min(t1.x, t2.x);
    minX = max(minX, t3.x);
    float minY = min(t1.y, t2.y);
    minY = min(minY, t3.y);
    float minZ = min(t1.z, t2.z);
    minZ = min(minZ, t3.z);
    BoundingBox bb;
    bb.maxP = float3(maxX, maxY, maxZ);
    bb.minP = float3(minX, minY, minZ);
    return bb;
}
float RayTriangleDistance(float3 origin, float3 direction, float3 triVert1, float3 triVert2, float3 triVert3)
{
    // Compute triangle normal
    float3 edge1 = triVert2 - triVert1;
    float3 edge2 = triVert3 - triVert1;
    float3 normal = cross(edge1, edge2);
    
    // Compute distance between ray and triangle plane
    float denom = dot(normal, direction);
    float distance;
    if (abs(denom) > 0.00001f)
    {
        float3 p = triVert1 - origin;
        distance = dot(p,
        normal) / denom;
        if (distance < 0.0f)
        {
            // Ray points away from triangle
            return -1.0f;
        }
    }
    else
    {
        // Ray is parallel to triangle plane
        return -1.0f;
    }
    
    // Compute barycentric coordinates
    float3 hitPoint = origin + distance * direction;
    float3 v0 = triVert2 - triVert1;
    float3 v1 = triVert3 - triVert1;
    float3 v2 = hitPoint - triVert1;
    float d00 = dot(v0, v0);
    float d01 = dot(v0, v1);
    float d11 = dot(v1, v1);
    float d20 = dot(v2, v0);
    float d21 = dot(v2, v1);
    float denom2 = d00 * d11 - d01 * d01;
    float v = (d11 * d20 - d01 * d21) / denom2;
    float w = (d00 * d21 - d01 * d20) / denom2;
    float u = 1.0f - v - w;
    
    // Check if hit point is inside triangle
    if ((v >= 0.0f) && (w >= 0.0f) && (v + w <= 1.0f))
    {
        // Hit point is inside triangle
        return distance;
    }
    else
    {
        // Hit point is outside triangle
        return -1.0f;
    }
}
// Create a RenderTexture with enableRandomWrite flag and set it
int TriangleCount;
float Time;
RWStructuredBuffer<SimplePointStr> SimplePoints;
RWStructuredBuffer<SimplePointStr> SimplePointsOut;
StructuredBuffer<SimpleTriangle> Triangles;
[numthreads(128,1,1)]
void CollisionKernel(uint3 id : SV_DispatchThreadID)
{
    SimplePointStr sp = SimplePoints[id.x];
    for (int i = 0; i < TriangleCount; i++) 
    {
        float3 origin = sp.position;
        float3 end = sp.position + sp.velocity;
        SimpleTriangle t = Triangles[i];
        if (t.t1 != id.x && t.t2 != id.x && t.t3 != id.x)
        {
            float3 t0 = SimplePoints[t.t1].position;
            float3 t1 = SimplePoints[t.t2].position;
            float3 t2 = SimplePoints[t.t3].position;
            BoundingBox bb;
            bb = CalculateBoundingBoxTriangle(t0, t1, t2);
            if (origin.x < bb.minP.x && end.x > bb.minP.x
                || end.x < bb.minP.x && origin.x > bb.minP.x
                || origin.x > bb.maxP.x && end.x < bb.maxP.x
                || end.x > bb.maxP.x && origin.x < bb.maxP.x
                || origin.x >= bb.minP.x && origin.x <= bb.maxP.x
                || end.x >= bb.minP.x && end.x <= bb.maxP.x) 
            {
                if (origin.y < bb.minP.y && end.y > bb.minP.y
                    || end.y < bb.minP.y && origin.y > bb.minP.y
                    || origin.y > bb.maxP.y && end.y < bb.maxP.y
                    || end.y > bb.maxP.y && origin.y < bb.maxP.y
                    || origin.y >= bb.minP.y && origin.y <= bb.maxP.y
                    || end.y >= bb.minP.y && end.y <= bb.maxP.y) 
                {
                    if (origin.z < bb.minP.z && end.z > bb.minP.z
                        || end.z < bb.minP.z && origin.z > bb.minP.z
                        || origin.z > bb.maxP.z && end.z < bb.maxP.z
                        || end.z > bb.maxP.z && origin.z < bb.maxP.z
                        || origin.z >= bb.minP.z && origin.z <= bb.maxP.z
                        || end.z >= bb.minP.z && end.z <= bb.maxP.z) 
                    {
                        float t = RayTriangleDistance(origin,sp.velocity, t0, t1, t2);
                        if (t >= 0 && length(sp.velocity) >= t)
                            sp.velocity = sp.velocity - normalize(sp.velocity) * t;

                    }
                }
            }
        }
    }
    sp.position = sp.position + sp.velocity; // * Time;
    SimplePointsOut[id.x] = sp;

}
