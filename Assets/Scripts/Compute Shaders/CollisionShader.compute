// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CollisionKernel
RWStructuredBuffer<float3> Debug;
RWStructuredBuffer<float3> Debug2;
struct Connectors
{
    float connectionL[24];
    int number[24];
};
struct SimplePointStr
{
    float3 position;
    float mass;
    int connectorCount;
    int ignorePhysics;
    float3 movePosition;
    float3 velocity;
    Connectors connectorPositions;
};
struct SimpleTriangle 
{
    int t1;
    int t2;
    int t3;
};
struct TriVert
{
    float3 t1;
    float3 t2;
    float3 t3;
};
struct BoundingBox {
    float3 maxP;
    float3 minP;
};
BoundingBox CalculateBoundingBoxTriangle(float3 t1, float3 t2, float3 t3) 
{
    float maxX = max(t1.x, t2.x);
    maxX = max(maxX, t3.x);
    float maxY = max(t1.y, t2.y);
    maxY = max(maxY, t3.y);
    float maxZ = max(t1.z, t2.z);
    maxZ = max(maxZ, t3.z);
    float minX = min(t1.x, t2.x);
    minX = min(minX, t3.x);
    float minY = min(t1.y, t2.y);
    minY = min(minY, t3.y);
    float minZ = min(t1.z, t2.z);
    minZ = min(minZ, t3.z);
    BoundingBox bb;
    bb.maxP = float3(maxX, maxY, maxZ);
    bb.minP = float3(minX, minY, minZ);
    return bb;
}
bool CheckIfInBoundingBox(float3 origin,float3 end,float3 t0, float3 t1, float3 t2)
{
    BoundingBox bb;
    bb = CalculateBoundingBoxTriangle(t0, t1, t2);
    if (origin.x < bb.minP.x && end.x > bb.minP.x
                || end.x < bb.minP.x && origin.x > bb.minP.x
                || origin.x > bb.maxP.x && end.x < bb.maxP.x
                || end.x > bb.maxP.x && origin.x < bb.maxP.x
                || origin.x >= bb.minP.x && origin.x <= bb.maxP.x
                || end.x >= bb.minP.x && end.x <= bb.maxP.x)
    {
        if (origin.y < bb.minP.y && end.y > bb.minP.y
                    || end.y < bb.minP.y && origin.y > bb.minP.y
                    || origin.y > bb.maxP.y && end.y < bb.maxP.y
                    || end.y > bb.maxP.y && origin.y < bb.maxP.y
                    || origin.y >= bb.minP.y && origin.y <= bb.maxP.y
                    || end.y >= bb.minP.y && end.y <= bb.maxP.y)
        {
            if (origin.z < bb.minP.z && end.z > bb.minP.z
                        || end.z < bb.minP.z && origin.z > bb.minP.z
                        || origin.z > bb.maxP.z && end.z < bb.maxP.z
                        || end.z > bb.maxP.z && origin.z < bb.maxP.z
                        || origin.z >= bb.minP.z && origin.z <= bb.maxP.z
                        || end.z >= bb.minP.z && end.z <= bb.maxP.z)
            {
                return true;

            }
        }
    }
    return false;
}
float RayTriangleDistance(float3 origin, float3 direction, float3 triVert1, float3 triVert2, float3 triVert3,out float3 CollisionVector)
{
    if (direction.x == 0 && direction.y == 0 && direction.z == 0)
    {
        return -1.0f;
    }
    float3 edge1 = triVert2 - triVert1;
    float3 edge2 = triVert3 - triVert1;
    float3 h = cross(direction, edge2);

    float a = dot(edge1, h);
    if (a > -0.00001f && a < 0.00001f)
    {
        return -1.0f;
    }
    float f = 1.0f / a;

    float3 s = origin - triVert1;
    float u = f * dot(s,h);
    if (u < 0 || u > 1.0f)
    {
        return -1.0f;
    }
    float3 q = cross(s, edge1);
    float v = f * dot(direction, q);
    if (v < 0 || u + v > 1.0f)
    {
        return -1.0f;
    }
    float t = f * dot(edge2, q);
    if (t > 0.00001f)
    {
        CollisionVector = normalize(cross(edge1, edge2)) * t;
        return t;
    }
    else
    {
        return -1.0f;
    }
    return -1.0f;
}
// Create a RenderTexture with enableRandomWrite flag and set it
int TriangleCount;

float Time;
RWStructuredBuffer<SimplePointStr> SimplePoints;
RWStructuredBuffer<SimplePointStr> SimplePointsOut;
StructuredBuffer<SimpleTriangle> Triangles;
RWStructuredBuffer<float3> internalCollisions;
[numthreads(128,1,1)]
void CollisionKernel(uint3 id : SV_DispatchThreadID)
{
    SimplePointStr sp = SimplePoints[id.x];
    if (length(sp.velocity) != 0)
    {
        //Debug[id.x] = sp.position;
        //Debug2[id.x] = sp.position + normalize(sp.velocity);
        
 
        for (int i = 0; i < TriangleCount; i++)
        {
            float3 origin = sp.position;
            float3 end = sp.position + normalize(sp.velocity);
            SimpleTriangle t = Triangles[i];
            if (t.t1 != id.x && t.t2 != id.x && t.t3 != id.x)
            {
                float3 t0 = SimplePoints[t.t1].position;
                float3 t1 = SimplePoints[t.t2].position;
                float3 t2 = SimplePoints[t.t3].position;
                if (CheckIfInBoundingBox(origin, sp.position + normalize(sp.velocity), t0, t1, t2))
                {
                    float3 collisionVector;
                    float dt = RayTriangleDistance(origin, normalize(sp.velocity), t0, t1, t2,collisionVector);
                    if (dt >= 0)
                    {
                        if (dt < 2 * length(sp.velocity))
                        {
                            sp.velocity = sp.velocity - normalize(collisionVector) * length(sp.velocity);
                            internalCollisions[t.t1] = internalCollisions[t.t1] + normalize(collisionVector) * 0.33f * length(sp.velocity);
                            internalCollisions[t.t2] = internalCollisions[t.t2] + normalize(collisionVector) * 0.33f * length(sp.velocity);
                            internalCollisions[t.t3] = internalCollisions[t.t3] + normalize(collisionVector) * 0.33f * length(sp.velocity);
                            //sp.velocity = cross(sp.velocity, collisionVector) * length(sp.velocity);
                        }
                    }
                }
                for (int j = 0; j < sp.connectorCount && j < 24; j++)
                {
                    float3 end = sp.position + sp.velocity;
                    int n = sp.connectorPositions.number[j];
                    SimplePointStr connection = SimplePoints[n];
                    if (t.t1 != n && t.t2 != n && t.t3 != n)
                    {
                        if (CheckIfInBoundingBox(end, connection.position, t0, t1, t2) && false)
                        {
                            float3 collisionVector;
                            float dt = RayTriangleDistance(end, normalize((connection.position) + (connection.velocity) - end), t0, t1, t2, collisionVector);
                            if (dt >= 0)
                            {
                                if (dt <= length((connection.position) + (connection.velocity) - end))
                                {
                                    internalCollisions[t.t1] = internalCollisions[t.t1] - normalize(collisionVector) * length(sp.velocity) * 0.33f;
                                    internalCollisions[t.t2] = internalCollisions[t.t2] - normalize(collisionVector) * length(sp.velocity) * 0.33f;
                                    internalCollisions[t.t3] = internalCollisions[t.t3] - normalize(collisionVector) * length(sp.velocity) * 0.33f;
                                    //sp.velocity = sp.velocity - sp.velocity * Time;
                                    sp.velocity = float3(0, 0, 0);
                                }
                                //sp.velocity = cross(sp.velocity, collisionVector) * length(sp.velocity);
                            }
                        }
                    }
                }

            }
        }
    }
    //sp.position = sp.position + sp.velocity; // * Time;
    SimplePointsOut[id.x] = sp;

}
