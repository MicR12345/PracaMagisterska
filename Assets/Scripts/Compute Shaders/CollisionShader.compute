// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CollisionKernel
struct Connectors
{
    float connectionL[24];
    int number[24];
};
struct SimplePointStr
{
    float3 position;
    float mass;
    int connectorCount;
    int ignorePhysics;
    float3 movePosition;
    float3 velocity;
    Connectors connectorPositions;
};
struct SimpleTriangle 
{
    int t1;
    int t2;
    int t3;
};
struct BoundingBox {
    float3 maxP;
    float3 minP;
};
BoundingBox CalculateBoundingBoxTriangle(float3 t1, float3 t2, float3 t3) 
{
    float maxX = max(t1.x, t2.x);
    maxX = max(maxX, t3.x);
    float maxY = max(t1.y, t2.y);
    maxY = max(maxY, t3.y);
    float maxZ = max(t1.z, t2.z);
    maxZ = max(maxZ, t3.z);
    float minX = min(t1.x, t2.x);
    minX = min(minX, t3.x);
    float minY = min(t1.y, t2.y);
    minY = min(minY, t3.y);
    float minZ = min(t1.z, t2.z);
    minZ = min(minZ, t3.z);
    BoundingBox bb;
    bb.maxP = float3(maxX, maxY, maxZ);
    bb.minP = float3(minX, minY, minZ);
    return bb;
}
bool CheckIfInBoundingBox(float3 t10,float3 t11, float3 t12,float3 t20, float3 t21, float3 t22)
{
    BoundingBox bb = CalculateBoundingBoxTriangle(t10, t11, t12);
    BoundingBox bb2 = CalculateBoundingBoxTriangle(t20, t21, t22);
    if (bb.minP.x > bb2.maxP.x || bb.maxP.x < bb2.minP.x)
    {
        return false;
    }
    if (bb.minP.y > bb2.maxP.y || bb.maxP.y < bb2.minP.y)
    {
        return false;
    }
    if (bb.minP.z > bb2.maxP.z || bb.maxP.z < bb2.minP.z)
    {
        return false;
    }
    return true;
}
float RayTriangleDistance(float3 origin, float3 direction, float3 triVert1, float3 triVert2, float3 triVert3, out float3 CollisionVector)
{
    if (direction.x == 0 && direction.y == 0 && direction.z == 0)
    {
        return -1.0f;
    }
    else
    {
        direction = normalize(direction);
    }
    float3 edge1 = triVert2 - triVert1;
    float3 edge2 = triVert3 - triVert1;
    float3 h = cross(direction, edge2);

    float a = dot(edge1, h);
    if (a > -0.00001f && a < 0.00001f)
    {
        return -1.0f;
    }
    float f = 1.0f / a;

    float3 s = origin - triVert1;
    float u = f * dot(s, h);
    if (u < 0 || u > 1.0f)
    {
        return -1.0f;
    }
    float3 q = cross(s, edge1);
    float v = f * dot(direction, q);
    if (v < 0 || u + v > 1.0f)
    {
        return -1.0f;
    }
    float t = f * dot(edge2, q);
    if (t > 0.00001f)
    {
        CollisionVector = cross(edge1,edge2);
        return t;
    }
    else
    {
        return -1.0f;
    }
    return -1.0f;
}
void ResolveIndirectCollision(float3 pos1, float3 pos2, float3 vel2, float3 tri1, float3 tri2, float3 tri3, out float3 newV)
{
    float3 collisionVector;
    int i = 0;
    float dt = RayTriangleDistance(pos1, pos2 + vel2 - pos1, tri1, tri2, tri3, collisionVector);
    while (dt > 0 && dt < length(pos2 + vel2 - pos1) && i < 3)
    {
        float3 collisionPoint = pos1 + normalize(pos2 + vel2 - pos1) * dt;
        vel2 = vel2 * 0.5;
        dt = RayTriangleDistance(pos1, pos2 + vel2 - pos1, tri1, tri2, tri3, collisionVector);
        i++;
        //vel2 = float3(0, 0, 0);
    }
    newV = vel2;
    //newV = float3(0, 0, 0);
}
int TriangleCount;

RWStructuredBuffer<SimplePointStr> SimplePoints;
RWStructuredBuffer<SimplePointStr> SimplePointsOut;
StructuredBuffer<SimpleTriangle> Triangles;
RWStructuredBuffer<float3> internalCollisions;
[numthreads(128,1,1)]
void CollisionKernel(uint3 id : SV_DispatchThreadID)
{
    SimpleTriangle st = Triangles[id.x];
    SimplePointStr sp1 = SimplePoints[st.t1];
    SimplePointStr sp2 = SimplePoints[st.t2];
    SimplePointStr sp3 = SimplePoints[st.t3];
    for (int i = 0; i < TriangleCount; i++)
    {
        SimpleTriangle st2 = Triangles[i];
        int samePoints = 0;
        if (st.t1 == st2.t1 || st.t1 == st2.t2 || st.t1 == st2.t3)
            samePoints++;
        if (st.t2 == st2.t1 || st.t2 == st2.t2 || st.t2 == st2.t3)
            samePoints++;
        if (st.t3 == st2.t1 || st.t3 == st2.t2 || st.t3 == st2.t3)
            samePoints++;
        if (samePoints < 1)
        {
            SimplePointStr sp21 = SimplePoints[st2.t1];
            SimplePointStr sp22 = SimplePoints[st2.t2];
            SimplePointStr sp23 = SimplePoints[st2.t3];
            if (CheckIfInBoundingBox(
                        sp1.position,
                        sp2.position,
                        sp3.position,
                        sp21.position,
                        sp22.position,
                        sp23.position
                    ))
            {
                float3 cv1, cv2, cv3;
                float dt1 = RayTriangleDistance(sp1.position, sp1.velocity, sp21.position + sp21.velocity, sp22.position + sp22.velocity, sp23.position + sp23.velocity, cv1);
                if (dt1 > 0 && dt1 < length(sp1.velocity))
                {
                    float3 ogV = sp1.velocity;
                    float len = length(sp1.velocity);
                    float dotpr1 = dot(cv1, sp1.velocity);
                    float3 collisionPoint = sp1.position + normalize(sp1.velocity) * dt1;
                    if (dotpr1 < 0)
                    {
                        cv1 = -cv1;
                    }
                    sp1.velocity = (collisionPoint + (cv1 * 0.01)) - sp1.position;
                    internalCollisions[st2.t1] = internalCollisions[st2.t1] + (sp1.velocity - ogV) / 3;
                    internalCollisions[st2.t2] = internalCollisions[st2.t2] + (sp1.velocity - ogV) / 3;
                    internalCollisions[st2.t3] = internalCollisions[st2.t3] + (sp1.velocity - ogV) / 3;
                }
                float dt2 = RayTriangleDistance(sp2.position, sp2.velocity, sp21.position + sp21.velocity, sp22.position + sp22.velocity, sp23.position + sp23.velocity, cv2);
                if (dt2 > 0 && dt2 < length(sp2.velocity))
                {
                    float3 ogV = sp2.velocity;
                    float len = length(sp2.velocity);
                    float dotpr1 = dot(cv2, sp2.velocity);
                    float3 collisionPoint = sp2.position + normalize(sp2.velocity) * dt2;
                    if (dotpr1 < 0)
                    {
                        cv2 = -cv2;
                    }
                    sp2.velocity = (collisionPoint + (cv2 * 0.01)) - sp2.position;
                    internalCollisions[st2.t1] = internalCollisions[st2.t1] + (sp2.velocity - ogV) / 3;
                    internalCollisions[st2.t2] = internalCollisions[st2.t2] + (sp2.velocity - ogV) / 3;
                    internalCollisions[st2.t3] = internalCollisions[st2.t3] + (sp2.velocity - ogV) / 3;
                }
                float dt3 = RayTriangleDistance(sp3.position, sp3.velocity, sp21.position + sp21.velocity, sp22.position + sp22.velocity, sp23.position + sp23.velocity, cv3);
                if (dt3 > 0 && dt3 < 2 * length(sp3.velocity))
                {
                    float3 ogV = sp3.velocity;
                    float len = length(sp3.velocity);
                    float dotpr1 = dot(cv3, sp3.velocity);
                    float3 collisionPoint = sp3.position + normalize(sp3.velocity) * dt3;
                    if (dotpr1 < 0)
                    {
                        cv3 = -cv3;
                    }
                    sp3.velocity = (collisionPoint + (cv3 * 0.01)) - sp3.position;
                    internalCollisions[st2.t1] = internalCollisions[st2.t1] + (sp3.velocity - ogV) / 3;
                    internalCollisions[st2.t2] = internalCollisions[st2.t2] + (sp3.velocity - ogV) / 3;
                    internalCollisions[st2.t3] = internalCollisions[st2.t3] + (sp3.velocity - ogV) / 3;
                }
                ResolveIndirectCollision(sp1.position, sp2.position, sp2.velocity, sp21.position + sp21.velocity, sp22.position + sp22.velocity, sp23.position + sp23.velocity, sp2.velocity);

                ResolveIndirectCollision(sp2.position, sp1.position, sp1.velocity, sp21.position + sp21.velocity, sp22.position + sp22.velocity, sp23.position + sp23.velocity, sp1.velocity);

                ResolveIndirectCollision(sp2.position, sp3.position, sp3.velocity, sp21.position + sp21.velocity, sp22.position + sp22.velocity, sp23.position + sp23.velocity, sp3.velocity);

                ResolveIndirectCollision(sp3.position, sp2.position, sp2.velocity, sp21.position + sp21.velocity, sp22.position + sp22.velocity, sp23.position + sp23.velocity, sp2.velocity);

                ResolveIndirectCollision(sp3.position, sp1.position, sp1.velocity, sp21.position + sp21.velocity, sp22.position + sp22.velocity, sp23.position + sp23.velocity, sp1.velocity);

                ResolveIndirectCollision(sp1.position, sp3.position, sp3.velocity, sp21.position + sp21.velocity, sp22.position + sp22.velocity, sp23.position + sp23.velocity, sp3.velocity);
                
                SimplePoints[st.t1] = sp1;
                SimplePoints[st.t2] = sp2;
                SimplePoints[st.t3] = sp3;
                SimplePointsOut[st.t1] = sp1;
                SimplePointsOut[st.t2] = sp2;
                SimplePointsOut[st.t3] = sp3;
            }

        }
        else
        {
            SimplePointsOut[st.t1] = sp1;
            SimplePointsOut[st.t2] = sp2;
            SimplePointsOut[st.t3] = sp3;
        }
    }


}
