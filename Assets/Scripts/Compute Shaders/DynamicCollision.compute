// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel DynamicCollision
struct Connectors
{
    float connectionL[24];
    int number[24];
};
struct SimplePointStr
{
    float3 position;
    float mass;
    int connectorCount;
    int ignorePhysics;
    float3 movePosition;
    float3 velocity;
    Connectors connectorPositions;
};
struct SimpleTriangle
{
    int t1;
    int t2;
    int t3;
};
struct BoundingBox
{
    float3 maxP;
    float3 minP;
};
BoundingBox CalculateBoundingBoxTriangle(float3 t1, float3 t2, float3 t3)
{
    float maxX = max(t1.x, t2.x);
    maxX = max(maxX, t3.x);
    float maxY = max(t1.y, t2.y);
    maxY = max(maxY, t3.y);
    float maxZ = max(t1.z, t2.z);
    maxZ = max(maxZ, t3.z);
    float minX = min(t1.x, t2.x);
    minX = min(minX, t3.x);
    float minY = min(t1.y, t2.y);
    minY = min(minY, t3.y);
    float minZ = min(t1.z, t2.z);
    minZ = min(minZ, t3.z);
    BoundingBox bb;
    bb.maxP = float3(maxX, maxY, maxZ);
    bb.minP = float3(minX, minY, minZ);
    return bb;
}
bool CheckIfInBoundingBox(float3 t10, float3 t11, float3 t12, float3 t20, float3 t21, float3 t22)
{
    BoundingBox bb = CalculateBoundingBoxTriangle(t10, t11, t12);
    BoundingBox bb2 = CalculateBoundingBoxTriangle(t20, t21, t22);
    if (bb.minP.x > bb2.maxP.x || bb.maxP.x < bb2.minP.x)
    {
        return false;
    }
    if (bb.minP.y > bb2.maxP.y || bb.maxP.y < bb2.minP.y)
    {
        return false;
    }
    if (bb.minP.z > bb2.maxP.z || bb.maxP.z < bb2.minP.z)
    {
        return false;
    }
    return true;
}
float RayTriangleDistance(float3 origin, float3 direction, float3 triVert1, float3 triVert2, float3 triVert3, out float3 CollisionVector)
{
    if (direction.x == 0 && direction.y == 0 && direction.z == 0)
    {
        return -1.0f;
    }
    else
    {
        direction = normalize(direction);
    }
    float3 edge1 = triVert2 - triVert1;
    float3 edge2 = triVert3 - triVert1;
    float3 h = cross(direction, edge2);

    float a = dot(edge1, h);
    if (a > -0.00001f && a < 0.00001f)
    {
        return -1.0f;
    }
    float f = 1.0f / a;

    float3 s = origin - triVert1;
    float u = f * dot(s, h);
    if (u < 0 || u > 1.0f)
    {
        return -1.0f;
    }
    float3 q = cross(s, edge1);
    float v = f * dot(direction, q);
    if (v < 0 || u + v > 1.0f)
    {
        return -1.0f;
    }
    float t = f * dot(edge2, q);
    if (t > 0.00001f)
    {
        CollisionVector = normalize(direction)*t;
        return t;
    }
    else
    {
        return -1.0f;
    }
    return -1.0f;
}
void ResolveIndirectCollision(float3 pos1, float3 pos2, float3 vel2, float3 tri1, float3 tri2, float3 tri3, out float3 newV)
{
    float3 collisionVector;
    int i = 0;
    float dt = RayTriangleDistance(pos1, pos2 + vel2 - pos1, tri1, tri2, tri3, collisionVector);
    while (dt > 0 && dt < length(pos2 + vel2 - pos1) && i < 3)
    {
        float3 collisionPoint = pos1 + normalize(pos2 + vel2 - pos1) * dt;
        vel2 = vel2 * 0.5;
        dt = RayTriangleDistance(pos1, pos2 + vel2 - pos1, tri1, tri2, tri3, collisionVector);
        i++;
        //vel2 = float3(0, 0, 0);
    }
    newV = vel2;
}
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
float Time;
int TriangleCount;
int dynTCount;
RWStructuredBuffer<SimplePointStr> SimplePoints;
RWStructuredBuffer<SimpleTriangle> Triangles;
RWStructuredBuffer<SimpleTriangle> dynTriangles;
RWStructuredBuffer<float3> endPoints;

[numthreads(128,1,1)]
void DynamicCollision(uint3 id : SV_DispatchThreadID)
{
    SimpleTriangle st = Triangles[id.x];
    SimplePointStr sp1 = SimplePoints[st.t1];
    SimplePointStr sp2 = SimplePoints[st.t2];
    SimplePointStr sp3 = SimplePoints[st.t3];
    for (int i = 0; i < dynTCount; i++)
    {
        SimpleTriangle st2 = dynTriangles[i];
        float3 sp21 = endPoints[st2.t1];
        float3 sp22 = endPoints[st2.t2];
        float3 sp23 = endPoints[st2.t3];
        if (CheckIfInBoundingBox(
                        sp1.position,
                        sp2.position,
                        sp3.position,
                        sp21,
                        sp22,
                        sp23
                    ))
        {
            float3 cv1, cv2, cv3;
            float dt1 = RayTriangleDistance(sp1.position, sp1.velocity, sp21, sp22, sp23, cv1);
            
            
                    
            if (dt1 > 0 && dt1 < length(sp1.velocity))
            {
                float3 ogV = sp1.velocity;
                float len = length(sp1.velocity);
                float dotpr1 = dot(cv1, sp1.velocity);
                float3 collisionPoint = sp1.position + normalize(sp1.velocity) * dt1;
                if (dotpr1 < 0)
                {
                    cv1 = -cv1;
                }
                sp1.velocity = (collisionPoint + (cv1 * 0.1)) - sp1.position;
            }
            float dt2 = RayTriangleDistance(sp2.position, sp2.velocity, sp21, sp22, sp23, cv2);
            if (dt2 > 0 && dt2 < length(sp2.velocity))
            {
                float3 ogV = sp2.velocity;
                float len = length(sp2.velocity);
                float dotpr1 = dot(cv2, sp2.velocity);
                float3 collisionPoint = sp2.position + normalize(sp2.velocity) * dt2;
                if (dotpr1 < 0)
                {
                    cv2 = -cv2;
                }
                sp2.velocity = (collisionPoint + (cv2 * 0.1)) - sp2.position;
            }
            float dt3 = RayTriangleDistance(sp3.position, sp3.velocity, sp21, sp22, sp23, cv3);
            if (dt3 > 0 && dt3 < length(sp3.velocity))
            {
                float3 ogV = sp3.velocity;
                float len = length(sp3.velocity);
                float dotpr1 = dot(cv3, sp3.velocity);
                float3 collisionPoint = sp3.position + normalize(sp3.velocity) * dt3;
                if (dotpr1 < 0)
                {
                    cv3 = -cv3;
                }
                sp3.velocity = (collisionPoint + (cv3 * 0.1)) - sp3.position;
            }
            ResolveIndirectCollision(sp1.position, sp2.position, sp2.velocity, sp21, sp22, sp23, sp2.velocity);
            ResolveIndirectCollision(sp2.position, sp1.position, sp1.velocity, sp21, sp22, sp23, sp1.velocity);
            ResolveIndirectCollision(sp2.position, sp3.position, sp3.velocity, sp21, sp22, sp23, sp3.velocity);
            ResolveIndirectCollision(sp3.position, sp2.position, sp2.velocity, sp21, sp22, sp23, sp2.velocity);
            ResolveIndirectCollision(sp3.position, sp1.position, sp1.velocity, sp21, sp22, sp23, sp1.velocity);
            ResolveIndirectCollision(sp1.position, sp3.position, sp3.velocity, sp21, sp22, sp23, sp3.velocity);
            SimplePoints[st.t1] = sp1;
            SimplePoints[st.t2] = sp2;
            SimplePoints[st.t3] = sp3;
        }
    }
}
