// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel PointKernel32
struct Connectors
{
    float connectionL[24];
    int number[24];
};
struct SimplePointStr
{
    float3 position;
    float mass;
    int connectorCount;
    int ignorePhysics;
    float3 movePosition;
    float3 velocity;
    Connectors connectorPositions;
};
float Time;
float k;
float friction;
RWStructuredBuffer<SimplePointStr> SimplePoints;
RWStructuredBuffer<SimplePointStr> SimplePointsOut;
RWStructuredBuffer<float3> internalCollisions;
[numthreads(128,1,1)]
void PointKernel32 (uint3 id : SV_DispatchThreadID)
{
    SimplePointStr sp = SimplePoints[id.x];
    sp.position = sp.position + sp.velocity;
    if (sp.ignorePhysics ==1) {
        SimplePointsOut[id.x] = sp;
    }
    else {
        float g = sp.mass * 9.81 * Time;
        sp.velocity = sp.velocity + float3(0, - g, 0);
        for (int i = 0; i < sp.connectorCount; i++) {
            SimplePointStr sp2 = SimplePoints[sp.connectorPositions.number[i]];
            float3 pp = sp2.position;
            float dist = distance(sp.position, pp);
            float3 direction = sp.position - pp;
            if (direction.x != 0 && direction.y != 0 && direction.z != 0)
            {
                float x = (dist - sp.connectorPositions.connectionL[i]);
                sp.velocity = sp.velocity + (normalize(direction) * -k * min(x, sp.connectorPositions.connectionL[i] * 2) * Time);
            }
            
        }
        sp.velocity = sp.velocity * (1 - friction);
        sp.velocity = sp.velocity + internalCollisions[id.x];
        internalCollisions[id.x] = float3(0, 0, 0);
        
        //sp.position = float3(sp.position.x + sp.velocity.x, sp.position.y + sp.velocity.y, sp.position.z + sp.velocity.z);
        SimplePointsOut[id.x] = sp;
    }
}
